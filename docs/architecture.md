# フェデレーションモデルの詳細設計

## システム全体の概要

このドキュメントでは、フェデレーションモデルにおけるデータフローと各コンポーネントの役割について詳細に説明します。このシステムは、送信用および受信用のインターフェース、複数のブロックチェーンチェーン（市町村チェーン、大陸チェーン、グローバルメインチェーン）、MongoDBによるデータ保存、DAppsおよびモバイルアプリを含む分散型アプリケーションを組み合わせて構築されています。

## コンポーネントの詳細

### 1. Global Main Chain（グローバルメインチェーン）

- **役割**: 各大陸チェーンから集約されたデータを統合・管理します。システム全体のデータの一元管理を行い、信頼性と整合性を確保します。
- **機能**:
  - 大陸チェーンからのブロックを受け取り、承認・統合。
  - データの整合性チェックと保護。
  - 保留リストの管理と共有。

### 2. Continental Chain（大陸チェーン）

- **役割**: 市町村チェーンから収集されたデータをグローバルメインチェーンに転送します。大陸レベルでのデータ管理と処理を担当します。
- **機能**:
  - 市町村チェーンからトランザクションデータを受け取る。
  - データの整合性と承認プロセスの実施。
  - グローバルメインチェーンへのブロック転送。

### 3. Municipal Chain（市町村チェーン）

- **役割**: 各市町村内でのトランザクションを処理します。ローカルなデータ管理とトランザクションの承認を行います。
- **機能**:
  - トランザクションの受信と保存（send_pendingおよびreceive_pending）。
  - トランザクションの承認とブロック生成。
  - トランザクションのMongoDBへの保存。

### 4. DApps（分散型アプリケーション）

- **役割**: ユーザーインターフェースを提供し、ユーザーがトランザクションを送信・受信できるようにします。
- **機能**:
  - トランザクションの作成・送信。
  - トランザクションのステータス確認。
  - データの視覚化と操作。

### 5. Mobile App（モバイルアプリ）

- **役割**: DAppsのモバイルバージョンで、外出先からのアクセスと操作を可能にします。
- **機能**:
  - モバイルデバイスからのトランザクション送信・受信。
  - プッシュ通知によるリアルタイム更新。
  - モバイル特有のユーザーインターフェースの提供。

### 6. MongoDB

- **役割**: トランザクションデータやブロックデータを永続的に保存します。データの検索や分析にも利用されます。
- **機能**:
  - トランザクションのステータス管理（pending、completeなど）。
  - ブロックデータの保存と管理。
  - データのバックアップとリストア。

## コンセンサスアルゴリズム

システムのブロックチェーンネットワークの整合性とセキュリティを確保するために、複数のコンセンサスアルゴリズムが採用されています。

### Delegated Proof of Stake (DPoS)

#### 構造定義

rust
struct DPoS {
    municipalities: Vec<String>,
    approved_representative: Option<String>,
}

impl DPoS {
    fn new(municipalities: Vec<String>) -> Self {
        Self {
            municipalities,
            approved_representative: None,
        }
    }

    fn elect_representative(&mut self) -> String {
        let representative = self.municipalities.choose(&mut rand::thread_rng()).unwrap().clone();
        self.approved_representative = Some(representative.clone());
        representative
    }

    fn approve_transaction(&self, transaction: &mut Transaction) -> Result<&str, &str> {
        if let Some(representative) = &self.approved_representative {
            transaction.signature = format!("approved_by_{}", representative);
            Ok("Transaction approved")
        } else {
            Err("No representative elected")
        }
    }
}

# RSAとNtruの併用による署名・暗号化
あなたのフェデレーションモデルにおいて、RSA.py ファイルが役立つ可能性がある場所をいくつか挙げてみます。特に、NTRUがメインの暗号技術である中、RSAが補完的に使える場面です。

ユーザー認証: login.html やログインの処理でRSAを使うと、ユーザーの認証データやセッショントークンをRSAで安全に署名・暗号化することが可能です。これにより、ユーザーのログイン時点でのセキュリティが強化され、NTRUを用いるメインの暗号化操作に進む前にユーザー認証が安全に完了するようになります。

公開鍵交換（Municipal Chain 間）: Municipal Chain同士の通信を安全に開始するために、NTRUの鍵交換を行う際の初期のメッセージや一時的な鍵交換にRSAを利用することが考えられます。RSAを介して、Municipal Chain間で必要な鍵情報を安全にやり取りし、その後NTRU暗号でのメイン通信に進む流れを整える役割を持たせることができます。

アプリの初期化や設定データの保護: アプリやDAppsの初期化時に、設定ファイルや個別のアプリケーションデータを暗号化しておくための一時的な手段としてRSAを使用することも可能です。

# 上記の公開鍵交換（Municipal Chain 間）をより詳細に
RSA鍵生成:
MunicipalChain::new()内で、RSAの鍵ペアを生成します。rsa_private_keyとrsa_public_keyは、それぞれRSAの秘密鍵と公開鍵として使われます。

NTRU鍵の生成:
同じnew()内でNTRUの鍵ペアも生成します。この公開鍵は他のMunicipal Chainに送信され、暗号化通信のために使われます。

RSA公開鍵の取得 (get_rsa_public_key):
他のMunicipal Chainがこの公開鍵を取得できるようにするメソッドです。この公開鍵を使ってNTRU公開鍵を暗号化します。

NTRU公開鍵の送信 (send_ntru_key):
他のMunicipal Chainに対し、自分のNTRU公開鍵を送信するためのメソッドです。この公開鍵はパートナーのRSA公開鍵で暗号化され、盗聴されても解読されないようにします。

NTRU公開鍵の受信と復号 (receive_ntru_key):
他のMunicipal Chainから送られてきた暗号化されたNTRU公開鍵を復号化し、通信相手ごとに保存します。

暗号化通信開始 (secure_communication_with_partner):
受信したNTRU公開鍵を使って、実際の通信メッセージをNTRUで暗号化し、安全な通信を確立します。

メッセージの復号 (decrypt_message):
受信した暗号化メッセージを復号化して内容を確認します。

サーバー側の設定
各Municipal Chainインスタンスで、このRSA鍵交換を呼び出すAPIエンドポイントを追加し、通信相手からRSA公開鍵を取得し、NTRU公開鍵の交換を行います。
初回通信以降は、secure_communication_with_partnerメソッドを利用して暗号化通信を行うことができます。

# pylance,rust-analyzerにてVSCODE上でコードをチェック。
まずは、静的なチェック機能を利用して、コードのエラーをすべて修正していく。赤いラインが入っている箇所をすべて潰していく。
このようなやり方で、DAppsやそれにかかわるモジュールのすべて、main_chainsも同様。それらのチェックが終わったら、
ようやく、下記の各種機能設計に入れる。まずは、赤いラインをすべて潰すこと。なお、rust-analyzerが機能していない、調べる。
※　Pylanceがsys.path.appendで追加したパスを認識していないか、IDEの設定がそれに対応していない可能性がありエラーとなっていても、実行時にコードは正常に動作していることはありえる。ここを十分注意してpylance,rust-analyzerを使うこと。

# ntru_encryption暗号・dilithium署名にてDApps側を、NTRU署名・ntru暗号にてブロックチェーン側を。
秘密鍵と公開鍵が上記の3種類もあり、名前を変えつつ判別しやすいようにしている:
実装がとても複雑で、お互いに素になるペアの数字をランダムに選べるかどうかが、アルゴリズムのポイントになる。
そのランダムに選ぶ処理で苦戦。
■app.py内でNTRUに関する設定や条件を変更すると、結果にも影響が出る可能性があります。具体的には、以下のような箇所が変更に影響を与えるポイントです：
1．NTRUのパラメータ設定: app.py内でNTRU暗号の設定（例えば、N_new、q_new、d_newなど）が行われている場合、これらのパラメータはNTRUの暗号化や復号化の結果に直接影響を与えます。もしこれらの設定を変更すれば、NTRU暗号化の動作が変わり、暗号化されたデータや復号後の結果が変わります。
2．鍵ペアの生成: 鍵ペアの生成（ntru_instance.genPublicKeyなど）を変更した場合、生成される公開鍵と秘密鍵が変わります。これにより、暗号化・復号化の結果、署名や検証の動作が変わることになります。
3．暗号化および復号化処理: 暗号化や復号化の方法（encrypt_with_ntruやdecrypt_transaction_data）を変更すれば、データの暗号化と復号化の結果も変わります。たとえば、暗号化処理が変更されれば、暗号化されたデータが異なる形式になり、復号処理の結果も変わります。
4．署名・検証の影響: NTRUを使って署名を行っている場合（例えば、sign_with_dilithium関数）、NTRUの設定や鍵が変わると、署名も異なったものになります。署名検証の結果も影響を受けるため、署名の有効性が変わる可能性があります。
⇒　つまり、app.pyのNTRU関連の設定を変更すると、暗号化、復号化、署名、検証などの処理に影響を与え、最終的な結果や動作が変わる可能性があるということです。それゆえ、dilithiumのコード、ntru_encryptionのコードをいじるだけでなく、app.py側の設定も重要な要素となるということ。これを念頭に、設定を変更する際はその影響範囲を十分に理解したうえで変更を行うことが重要です。

# wallet付与
ログイン後にウォレットの残高を表示するために、ユーザーが入力したウォレットアドレスに基づいて immuDB から残高を計算し、
表示する処理を追加した。ウォレット残高を動的に管理し、ユーザーのアクション（送金など）が行われる度に、残高を再計算して
表示します。トランザクション送信フォームを作成し、送金後に immuDB にデータを保存して、ウォレット残高を更新します。
このように、index.html と app.py の連携を通じて、ウォレット情報とトランザクション管理を実現できます。なお、ウォレットはimuuDBのみでは不安なため、mongoDBとの二重管理にしたい。万が一ハッキングされても、immuDBとmongoDBの差額を常にチェックしており、差がでれば、アラーム処理がなされるとともに、多い方に合わせる処理が走るという仕組みにしたい。
wallet_db フォルダーは必要？

# ポート処理・アドレス付与
ポート処理・アドレス付与として、flaskポート、mongoDBポート、immuDBポート、をそれぞれmunicipal_chainやcontinental_main_chainごとにアドレスを設定していかねばならない。あと、エラー時のデフォルトポートやアドレスも
設定していかねばならない。ここは後から費用が発生するところなので、できるだけ少ないポートやアドレスになるように
する必要がある。

# login処理
login処理として、まず、login.htmlの画面が出て、パスワードとIDを入れればログイン出来るように設計する。
この時の署名処理はRSA署名で行う。その後、dashboad.htmlの画面が出て、受信用画面か、送信用画面を選ぶボタンが出てくる。
送信用ならば、sending_dappsのindex.htmlの画面が出て、送信情報を入力することになる。
受信用ならば、receiving_dappsのindex.htmlの画面が出て、受信用情報をチェックし、受信ボタンを押すと、
transactionの完了処理へと移行する。それゆえ、受信画面に、receive_pendingのtransaction一覧が表示されるようにすること。
その該当トランザクションの横にそれぞれの受信ボタンが動的に表示されるようすること。ここは未実装。

さらに困難を極めるのが、科目が今後増えるかも知れないので、動的にattributesという項目にてブロックチェーンの
transacrionにデータを渡すような処理をしている（キーとバリューのペアで、複数のキーを自在に増減できる）。
このattributesの処理はDAppsからmain_chainのすべてに跨がる処理となる。

# MongoDBをメインに多種のデータが同時に保存処理されていく設計に
Analytics_DBだけでもいくつもあるし、send,send_pending,receive,receive_pending,completeという
通常のtransaction処理だけでも5つの状態を保持していくことになるのだから、きちんとした設計が必要だ。
なお、完了してブロックになれば、immu_DBに保存されるようにする。

# Dokerによる一括テスト
ポート処理・アドレス付与などを考慮して幾つものポートを立ち上げていないとテストできない。
それを手動で10も20も立ち上げていたらややこしい。それゆえ、Dokerを使うと、そのテストの時だけポートを開き、
テストが終わるとポートを閉じるという設計ができる。これで、一括テストができるので、そのようなテスト設計も必要。
テスト用の設計をいまいちど見直す。

# 愛⇒和 へ名前を変更
愛は東洋では他者への無償の愛として受け入れられるが、西洋では神の愛となり、無償の愛が受け入れられるか不可思議。
そこで、和、という言葉に変更する。英語ではHarmonyとなる。西洋において、「Harmony」は一般的に「調和」や「協調」を
意味し、音楽や美術の分野でも使用されます。しかし、個人主義が強調される文化では、「Harmony」の概念が集団主義や
同調圧力と結びつけられ、ネガティブに捉えられる可能性もあります。しかし、愛よりは私の概念が広く伝わり安いと判断。
そこで、すべての名前と、仕訳科目も、変更していく。
段階的に「和貨」・「Harmony Token」に、「和記」・Harmony Record」に、「和の行動」・「Harmony Actions」に変更します。
あと、仕訳科目や分析科目も名前のみ変更し、概念はそのまま用いる。

# DPosの承認行為
送信されたtransactionは、send状態でmunicipal_chainにやってきてここでDPosにて3人の代表者に承認されれば、
send_pending状態で保存される。そして受信処理がなされて、municipal_chainにて受信の承認行為が3人の代表者によって
なされれば、complete状態となって保存される。さらに5秒か100トランザクションとなってブロックチェーンとなれば、
ここでもDPosにて承認行為が行われて、continental_main_chainへと送信され、immuDBに保存される。

# gossipアルゴリズムにて完了したブロックが他のノードに分散保存される
完了したtransactionはanalytics_DBに保存される。そして、ブロックになるまで待って、ブロックになれば
immu_DBに保存されるだけでなく、他のノードと分散処理されて、保存される。ブロックの条件は、5秒か100ブロックが溜まれば、
ブロックチェーンとなって承認行為のプロセスへ進む。
ここがいわゆるブロックチェーンゆえの分散処理となり、ここがまだ十分に実装されていない。

# 分散負荷の仕組み
１．トランザクションのルーティング：トランザクションの処理負荷を分散させるため、各ノード間でトランザクションを動的に
ルーティング。各ノードは現在の負荷状況をモニタリングし、処理可能なノードにタスクを委譲。
２．市町村ごとのゲートウェイノードを設置し、トランザクションの優先順位付けとキュー管理を行う。
３．代表者ノードの動的再選出：負荷が偏りすぎた場合、代表者ノードをリアルタイムで変更可能にする。
これは必要だな。負荷分散しておかないと、ノードがスマートフォンだったり、古いPCだったりすると容量が足りなくなる。
あと、フルノードとライトノードの設計も必要。ライトノードにどこまでの機能を負荷させるかも必要。

# 公開鍵交換（Analytics_DAppsとMunicipal_Chain 間）をより詳細に
分析でブロックチェーンのプログラムに入り込む際に、セキュリティを最重視せねばならない。RSAにてか、ntruと併用か？
分析時等のDAppsとの鍵交換のプロセスなど、緻密な設計が必要。あと、municipal_chainやcontinental_main_chain
へのgossipアルゴリズムによる分散処理される際にも鍵交換プロセスが発生するので、設計すべき。

# DApps、main_chainをモジュール分割することに
1000行を超えるプログラムにならないよう、多ければモジュール化してわけていく。
どのような機能毎にモジュール化していくのか、コードを見ながらわけていくので、ルール化はしていない。
順番にapp.pyから各main_chainをモジュール化していく

# githubでのバージョン管理をうまく設計
githubへの保存をもう少し頻繁に行い、データが飛ぶリスクを防ぐ。
さらに、Cドライブに保存されている各種のプログラムをDドライブへ移行して、持ち運びできる状態にすべし。
そうすれば、他の人に引き継ぎができる。引き継ぎの設計もしていく必要がある。

# global_main_chainは非同期処理に
バッチ処理で、continental_main_chainにつながるような処理にしたい。
何時とか決めるのか、それとも、運営管理者が手動でやるのか、そんなわけにはいかないのでルール化が必要。
他の事例も研究する。もっともセキュリティが高くなるよう設計が必要。

# 個人情報の取得を要注意
マイナンバーを表記させないよう、見えないように表示するのか、運営者でもわからないようにすること。必要ないデータゆえに。
また、個人が本人で有るということを証明できるよう、各市町村との連携プログラムも必要。
第三者の個人情報管理機構のような財団法人との契約になるのか、ここはさらに詰める必要がある。

# 仕訳の自動処理
openAIのAPIを持ってきてchatGTPに言葉から自動仕訳して愛記の科目を生成するプロセスを導入:
データベースにも保存していく。さらに難しいのが、自動仕訳をしていき新科目の提案までchatGTPにさせる。
さらに難しいのが、過去事例を参照に、仕訳をしてもらえるような処理を入れているが、きちんと参照して仕訳ができるのか、
チェックする機能も必要となる。チェック機能はまだ未実装。

さらに困難を極めるのが、科目が今後増えるかも知れないので、動的にattributesという項目にてブロックチェーンの
transacrionにデータを渡すような処理をしている（キーとバリューのペアで、複数のキーを自在に増減できる）。
このattributesの処理はDAppsからmain_chainのすべてに跨がる処理となる。

# QRコードを処理するフローに
最もハードルが高いのがこのQRコード処理だ。主語、述語などが無いような文章を解析して、自動仕訳をして、
さらに相手の名前が分かるのか分からないのか、分かるなら相手の名前を入れた入力用の画面にて入力して貰う。
一方、分からないのなら、QRコードを相手に提示して、相手に読みってももらい、愛記処理をするというプロセスを実装する。
まだ、まったくこのフローは未実装。

# PoHの設計
PoHの設計には、Turbinやその他の分散処理なども含め、solanaを徹底研究して、同じような分散処理を実現させる。
仮にだが、sorana風なコードは簡単に埋め込んだ。これを起点にしてもっと色んな処理を入れていくべし。それにより、
どれだけ分散されるかのシミュレーションテストも設計して、やってみるべし。
まだ未実装。

# PoPの設計
PoPの設計には、位置情報の取り方をどうするのか、詳細に設計が必要。
市町村の内外だけを判別するような方法が望ましいが、イベントで実際の場所を使うケースもあるので悩ましい。
どのようにすれば早く処理できるのか、速度も重要な要素なので、十分に調べるべき。もちろんセキュリティも大切。
スマートフォン、5G、6G、WiFiの扱いなど、十分にしらべる。

# セキュリティの設計
専門家のサイトやどこにセキュリティ不安があるのか、全体をとおして脆弱な部分を判別するようなハッキングの設計も
やってみると良い。そうすると、ハッカーが狙ってくる場所がわかるはず。そんなハッキングの設計も盛り込む。

# Analytics_DAppsがいくつかデフォルトで用意したい
Analytics_DAppsで他人が実装依頼してくるものものあれば、当方がデフォルトで用意するモノもいくつかある。
デフォルトで用意するモノは設計が必要である。教育・研修プラットフォーム、投資分析プラットフォーム、
愛記分析プラットフォーム、次元別生命体分析プラットフォーム、企業間連携分析プラットフォームなど。

